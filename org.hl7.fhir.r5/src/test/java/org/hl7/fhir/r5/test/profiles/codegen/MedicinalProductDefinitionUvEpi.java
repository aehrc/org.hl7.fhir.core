package org.hl7.fhir.r5.test.profiles.codegen;

import java.util.List;
import java.util.ArrayList;
import javax.annotation.Nullable;
import java.util.Date;


import org.hl7.fhir.r5.context.IWorkerContext;
import org.hl7.fhir.r5.model.*;
import org.hl7.fhir.r5.profilemodel.PEBuilder;
import org.hl7.fhir.r5.profilemodel.PEInstance;
import org.hl7.fhir.r5.profilemodel.PEBuilder.PEElementPropertiesPolicy;
import org.hl7.fhir.r5.profilemodel.gen.PEGeneratedBase;
import org.hl7.fhir.r5.profilemodel.gen.Min;
import org.hl7.fhir.r5.profilemodel.gen.Max;
import org.hl7.fhir.r5.profilemodel.gen.Label;
import org.hl7.fhir.r5.profilemodel.gen.Doco;
import org.hl7.fhir.r5.profilemodel.gen.BindingStrength;
import org.hl7.fhir.r5.profilemodel.gen.ValueSet;
import org.hl7.fhir.r5.profilemodel.gen.MustSupport;
import org.hl7.fhir.r5.profilemodel.gen.Definition;


// Generated by the HAPI Java Profile Generator, 5/11/24, 6:00 pm

/**
 * A medicinal product, being a substance or combination of substances that is 
 * intended to treat, prevent or diagnose a disease, or to restore, correct or 
 * modify physiological functions by exerting a pharmacological, immunological or 
 * metabolic action. This resource is intended to define and detail such products 
 * and their properties, for uses other than direct patient care (e.g. regulatory 
 * use, or drug catalogs).
 *
 */
public class MedicinalProductDefinitionUvEpi extends PEGeneratedBase {

  public static final String CANONICAL_URL = "http://hl7.org/fhir/uv/emedicinal-product-info/StructureDefinition/MedicinalProductDefinition-uv-epi|1.0.0";

  @Min("0") @Max("1") @Doco("")
  private String id;  // 

  @Min("0") @Max("*") @Doco("Additional content defined by implementations")
  @Definition("May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and managable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.")
  private List<Extension> extensions = new ArrayList<>();  // Additional content defined by implementations

  @Min("0") @Max("*") @Doco("Extensions that cannot be ignored")
  @Definition("May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and managable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.\n\nModifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).")
  private List<Extension> modifierExtensions = new ArrayList<>();  // Extensions that cannot be ignored

  @Min("1") @Max("*") @Doco("Business identifier for this product. Could be an MPID")
  @Definition("Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.")
  private List<Identifier> identifiers = new ArrayList<>();// @NotNull  // Business identifier for this product. Could be an MPID

  @Min("0") @Max("*") @Doco("Marketing status of the medicinal product, in contrast to marketing authorization")
  @Definition("Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).")
  private List<MarketingStatus> marketingStatuses = new ArrayList<>();  // Marketing status of the medicinal product, in contrast to marketing authorization

  @Min("0") @Max("*") @Doco("Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes")
  @Definition("Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).")
  private List<Reference> comprisedOfs = new ArrayList<>();  // Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes

  @Min("0") @Max("*") @Doco("Additional documentation about the medicinal product")
  @Definition("Additional information or supporting documentation about the medicinal product.")
  private List<Reference> attachedDocuments = new ArrayList<>();  // Additional documentation about the medicinal product

  @Min("0") @Max("*") @Doco("A master file for the medicinal product (e.g. Pharmacovigilance System Master File)")
  @Definition("A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.")
  private List<Reference> masterFiles = new ArrayList<>();  // A master file for the medicinal product (e.g. Pharmacovigilance System Master File)

  @Min("0") @Max("*") @Doco("A product specific contact, person (in a role), or an organization")
  @Definition("A product specific contact, person (in a role), or an organization.")
  private List<BackboneElement> contacts = new ArrayList<>();  // A product specific contact, person (in a role), or an organization

  @Min("0") @Max("*") @Doco("Clinical trials or studies that this product is involved in")
  @Definition("Clinical trials or studies that this product is involved in.")
  private List<Reference> clinicalTrials = new ArrayList<>();  // Clinical trials or studies that this product is involved in

  @Min("0") @Max("*") @Doco("A code that this product is known by, within some formal terminology")
  @BindingStrength("example") @ValueSet("http://hl7.org/fhir/ValueSet/medication-codes")
  @Definition("A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.")
  private List<Coding> codes = new ArrayList<>();  // A code that this product is known by, within some formal terminology

  @Min("1") @Max("*") @Doco("The product's name, including full name and possibly coded parts")
  @Definition("The product's name, including full name and possibly coded parts.")
  private List<BackboneElement> names = new ArrayList<>();// @NotNull  // The product's name, including full name and possibly coded parts

  @Min("0") @Max("*") @Doco("Reference to another product, e.g. for linking authorised to investigational product")
  @Definition("Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.")
  private List<BackboneElement> crossReferences = new ArrayList<>();  // Reference to another product, e.g. for linking authorised to investigational product

  @Min("0") @Max("*") @Doco("A manufacturing or administrative process for the medicinal product")
  @Definition("A manufacturing or administrative process or step associated with (or performed on) the medicinal product.")
  private List<BackboneElement> operations = new ArrayList<>();  // A manufacturing or administrative process for the medicinal product

  @Min("0") @Max("*") @Doco("Key product features such as \"sugar free\", \"modified release\"")
  @Definition("Allows the key product features to be recorded, such as \"sugar free\", \"modified release\", \"parallel import\".")
  private List<BackboneElement> characteristics = new ArrayList<>();  // Key product features such as "sugar free", "modified release"


  /**
   * Parameter-less constructor.
   *
   */
  public MedicinalProductDefinitionUvEpi() {
  }

  /**
   * Construct an instance of the object, and fill out all the fixed values 
   *
   */
  public MedicinalProductDefinitionUvEpi(IWorkerContext context) {
    workerContext = context;
    PEBuilder builder = new PEBuilder(context, PEElementPropertiesPolicy.EXTENSION, true);
    PEInstance src = builder.buildPEInstance(CANONICAL_URL, builder.createResource(CANONICAL_URL, false));
    load(src);
  }

  /**
   * Populate an instance of the object based on this source object 
   *
   */
  public static MedicinalProductDefinitionUvEpi fromSource(IWorkerContext context, MedicinalProductDefinition source) {
    MedicinalProductDefinitionUvEpi theThing = new MedicinalProductDefinitionUvEpi();
    theThing.workerContext = context;
    PEBuilder builder = new PEBuilder(context, PEElementPropertiesPolicy.EXTENSION, true);
    PEInstance src = builder.buildPEInstance(CANONICAL_URL, source);
    theThing.load(src);
    return theThing;
  }


  public void load(PEInstance src) {
    clear();
    if (src.hasChild("id")) {
      id = ((IdType) src.child("id").asDataType()).getValue();
    }
    for (PEInstance item : src.children("extension")) {
      extensions.add((Extension) item.asDataType());
    }
    for (PEInstance item : src.children("modifierExtension")) {
      modifierExtensions.add((Extension) item.asDataType());
    }
    for (PEInstance item : src.children("identifier")) {
      identifiers.add((Identifier) item.asDataType());
    }
    for (PEInstance item : src.children("marketingStatus")) {
      marketingStatuses.add((MarketingStatus) item.asDataType());
    }
    for (PEInstance item : src.children("comprisedOf")) {
      comprisedOfs.add((Reference) item.asDataType());
    }
    for (PEInstance item : src.children("attachedDocument")) {
      attachedDocuments.add((Reference) item.asDataType());
    }
    for (PEInstance item : src.children("masterFile")) {
      masterFiles.add((Reference) item.asDataType());
    }
    for (PEInstance item : src.children("contact")) {
      contacts.add((BackboneElement) item.asElement());
    }
    for (PEInstance item : src.children("clinicalTrial")) {
      clinicalTrials.add((Reference) item.asDataType());
    }
    for (PEInstance item : src.children("code")) {
      codes.add((Coding) item.asDataType());
    }
    for (PEInstance item : src.children("name")) {
      names.add((BackboneElement) item.asElement());
    }
    for (PEInstance item : src.children("crossReference")) {
      crossReferences.add((BackboneElement) item.asElement());
    }
    for (PEInstance item : src.children("operation")) {
      operations.add((BackboneElement) item.asElement());
    }
    for (PEInstance item : src.children("characteristic")) {
      characteristics.add((BackboneElement) item.asElement());
    }

  }

  /**
   * Build a instance of the underlying object based on this wrapping object 
   *
   */
  public MedicinalProductDefinition build(IWorkerContext context) {
    workerContext = context;
    return build();
  }

  /**
   * Build a instance of the underlying object based on this wrapping object 
   *
   */
  public MedicinalProductDefinition build() {
    MedicinalProductDefinition theThing = new MedicinalProductDefinition();
    PEBuilder builder = new PEBuilder(workerContext, PEElementPropertiesPolicy.EXTENSION, true);
    PEInstance tgt = builder.buildPEInstance(CANONICAL_URL, theThing);
    save(tgt, false);
    return theThing;
  }

  /**
   * Save this profile class into an existing resource (overwriting anything that 
   * exists in the profile) 
   *
   */
  public void save(IWorkerContext context, MedicinalProductDefinition dest, boolean nulls) {
    workerContext = context;
    PEBuilder builder = new PEBuilder(context, PEElementPropertiesPolicy.EXTENSION, true);
    PEInstance tgt = builder.buildPEInstance(CANONICAL_URL, dest);
    save(tgt, nulls);
  }

  public void save(PEInstance tgt, boolean nulls) {
    tgt.clear("id");
    if (id != null) {
      tgt.makeChild("id").data().setProperty("value", new IdType(id));
    }
    tgt.clear("extension");
    for (Extension item : extensions) {
      tgt.addChild("extension", item);
    }
    tgt.clear("modifierExtension");
    for (Extension item : modifierExtensions) {
      tgt.addChild("modifierExtension", item);
    }
    tgt.clear("identifier");
    for (Identifier item : identifiers) {
      tgt.addChild("identifier", item);
    }
    tgt.clear("marketingStatus");
    for (MarketingStatus item : marketingStatuses) {
      tgt.addChild("marketingStatus", item);
    }
    tgt.clear("comprisedOf");
    for (Reference item : comprisedOfs) {
      tgt.addChild("comprisedOf", item);
    }
    tgt.clear("attachedDocument");
    for (Reference item : attachedDocuments) {
      tgt.addChild("attachedDocument", item);
    }
    tgt.clear("masterFile");
    for (Reference item : masterFiles) {
      tgt.addChild("masterFile", item);
    }
    tgt.clear("contact");
    for (BackboneElement item : contacts) {
      tgt.addChild("contact", item);
    }
    tgt.clear("clinicalTrial");
    for (Reference item : clinicalTrials) {
      tgt.addChild("clinicalTrial", item);
    }
    tgt.clear("code");
    for (Coding item : codes) {
      tgt.addChild("code", item);
    }
    tgt.clear("name");
    for (BackboneElement item : names) {
      tgt.addChild("name", item);
    }
    tgt.clear("crossReference");
    for (BackboneElement item : crossReferences) {
      tgt.addChild("crossReference", item);
    }
    tgt.clear("operation");
    for (BackboneElement item : operations) {
      tgt.addChild("operation", item);
    }
    tgt.clear("characteristic");
    for (BackboneElement item : characteristics) {
      tgt.addChild("characteristic", item);
    }

  }

  public String getId() {
    return id;
  }

  public MedicinalProductDefinitionUvEpi setId(String value) {
    this.id = value;
    return this;
  }

  public boolean hasId() {
    return id != null;
  }

  /**
   * May be used to represent additional information that is not part of the basic 
   * definition of the resource. To make the use of extensions safe and managable, 
   * there is a strict set of governance applied to the definition and use of 
   * extensions. Though any implementer can define an extension, there is a set of 
   * requirements that SHALL be met as part of the definition of the extension.
   *
   */
  public List<Extension> getExtensions() {
    if (extensions == null) { extensions = new ArrayList<>(); }
    return extensions;
  }

  public boolean hasExtensions() {
    return extensions != null && !extensions.isEmpty();
  }

  public Extension addExtension() {
    Extension theThing = new Extension();
    getExtensions().add(theThing);
    return theThing;
  }

  public boolean hasExtension(Extension item) {
    return hasExtensions() && extensions.contains(item);
  }

  public void removeExtension(Extension item) {
    if (hasExtension(item)) {
      extensions.remove(item);
    }
  }


  /**
   * May be used to represent additional information that is not part of the basic 
   * definition of the resource and that modifies the understanding of the element 
   * that contains it and/or the understanding of the containing element's 
   * descendants. Usually modifier elements provide negation or qualification. To 
   * make the use of extensions safe and managable, there is a strict set of 
   * governance applied to the definition and use of extensions. Though any 
   * implementer is allowed to define an extension, there is a set of requirements 
   * that SHALL be met as part of the definition of the extension. Applications 
   * processing a resource are required to check for modifier extensions.
   *
   * 
   *
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or 
   * DomainResource (including cannot change the meaning of modifierExtension 
   * itself).
   *
   */
  public List<Extension> getModifierExtensions() {
    if (modifierExtensions == null) { modifierExtensions = new ArrayList<>(); }
    return modifierExtensions;
  }

  public boolean hasModifierExtensions() {
    return modifierExtensions != null && !modifierExtensions.isEmpty();
  }

  public Extension addModifierExtension() {
    Extension theThing = new Extension();
    getModifierExtensions().add(theThing);
    return theThing;
  }

  public boolean hasModifierExtension(Extension item) {
    return hasModifierExtensions() && modifierExtensions.contains(item);
  }

  public void removeModifierExtension(Extension item) {
    if (hasModifierExtension(item)) {
      modifierExtensions.remove(item);
    }
  }


  /**
   * Business identifier for this product. Could be an MPID. When in development or 
   * being regulated, products are typically referenced by official identifiers, 
   * assigned by a manufacturer or regulator, and unique to a product (which, when 
   * compared to a product instance being prescribed, is actually a product type). 
   * See also MedicinalProductDefinition.code.
   *
   */
  public List<Identifier> getIdentifiers() {
    if (identifiers == null) { identifiers = new ArrayList<>(); }
    return identifiers;
  }

  public boolean hasIdentifiers() {
    return identifiers != null && !identifiers.isEmpty();
  }

  public Identifier addIdentifier() {
    Identifier theThing = new Identifier();
    getIdentifiers().add(theThing);
    return theThing;
  }

  public boolean hasIdentifier(Identifier item) {
    return hasIdentifiers() && identifiers.contains(item);
  }

  public void removeIdentifier(Identifier item) {
    if (hasIdentifier(item)) {
      identifiers.remove(item);
    }
  }


  /**
   * Marketing status of the medicinal product, in contrast to marketing 
   * authorization. This refers to the product being actually 'on the market' as 
   * opposed to being allowed to be on the market (which is an authorization).
   *
   */
  public List<MarketingStatus> getMarketingStatuses() {
    if (marketingStatuses == null) { marketingStatuses = new ArrayList<>(); }
    return marketingStatuses;
  }

  public boolean hasMarketingStatuses() {
    return marketingStatuses != null && !marketingStatuses.isEmpty();
  }

  public MarketingStatus addMarketingStatus() {
    MarketingStatus theThing = new MarketingStatus();
    getMarketingStatuses().add(theThing);
    return theThing;
  }

  public boolean hasMarketingStatus(MarketingStatus item) {
    return hasMarketingStatuses() && marketingStatuses.contains(item);
  }

  public void removeMarketingStatus(MarketingStatus item) {
    if (hasMarketingStatus(item)) {
      marketingStatuses.remove(item);
    }
  }


  /**
   * Types of medicinal manufactured items and/or devices that this product consists 
   * of, such as tablets, capsule, or syringes. Used as a direct link when the item's 
   * packaging is not being recorded (see also 
   * PackagedProductDefinition.package.containedItem.item).
   *
   */
  public List<Reference> getComprisedOfs() {
    if (comprisedOfs == null) { comprisedOfs = new ArrayList<>(); }
    return comprisedOfs;
  }

  public boolean hasComprisedOfs() {
    return comprisedOfs != null && !comprisedOfs.isEmpty();
  }

  public Reference addComprisedOf() {
    Reference theThing = new Reference();
    getComprisedOfs().add(theThing);
    return theThing;
  }

  public boolean hasComprisedOf(Reference item) {
    return hasComprisedOfs() && comprisedOfs.contains(item);
  }

  public void removeComprisedOf(Reference item) {
    if (hasComprisedOf(item)) {
      comprisedOfs.remove(item);
    }
  }


  /**
   * Additional information or supporting documentation about the medicinal product.
   *
   */
  public List<Reference> getAttachedDocuments() {
    if (attachedDocuments == null) { attachedDocuments = new ArrayList<>(); }
    return attachedDocuments;
  }

  public boolean hasAttachedDocuments() {
    return attachedDocuments != null && !attachedDocuments.isEmpty();
  }

  public Reference addAttachedDocument() {
    Reference theThing = new Reference();
    getAttachedDocuments().add(theThing);
    return theThing;
  }

  public boolean hasAttachedDocument(Reference item) {
    return hasAttachedDocuments() && attachedDocuments.contains(item);
  }

  public void removeAttachedDocument(Reference item) {
    if (hasAttachedDocument(item)) {
      attachedDocuments.remove(item);
    }
  }


  /**
   * A master file for the medicinal product (e.g. Pharmacovigilance System Master 
   * File). Drug master files (DMFs) are documents submitted to regulatory agencies 
   * to provide confidential detailed information about facilities, processes or 
   * articles used in the manufacturing, processing, packaging and storing of drug 
   * products.
   *
   */
  public List<Reference> getMasterFiles() {
    if (masterFiles == null) { masterFiles = new ArrayList<>(); }
    return masterFiles;
  }

  public boolean hasMasterFiles() {
    return masterFiles != null && !masterFiles.isEmpty();
  }

  public Reference addMasterFile() {
    Reference theThing = new Reference();
    getMasterFiles().add(theThing);
    return theThing;
  }

  public boolean hasMasterFile(Reference item) {
    return hasMasterFiles() && masterFiles.contains(item);
  }

  public void removeMasterFile(Reference item) {
    if (hasMasterFile(item)) {
      masterFiles.remove(item);
    }
  }


  /**
   * A product specific contact, person (in a role), or an organization.
   *
   */
  public List<BackboneElement> getContacts() {
    if (contacts == null) { contacts = new ArrayList<>(); }
    return contacts;
  }

  public boolean hasContacts() {
    return contacts != null && !contacts.isEmpty();
  }

  public boolean hasContact(BackboneElement item) {
    return hasContacts() && contacts.contains(item);
  }

  public void removeContact(BackboneElement item) {
    if (hasContact(item)) {
      contacts.remove(item);
    }
  }


  /**
   * Clinical trials or studies that this product is involved in.
   *
   */
  public List<Reference> getClinicalTrials() {
    if (clinicalTrials == null) { clinicalTrials = new ArrayList<>(); }
    return clinicalTrials;
  }

  public boolean hasClinicalTrials() {
    return clinicalTrials != null && !clinicalTrials.isEmpty();
  }

  public Reference addClinicalTrial() {
    Reference theThing = new Reference();
    getClinicalTrials().add(theThing);
    return theThing;
  }

  public boolean hasClinicalTrial(Reference item) {
    return hasClinicalTrials() && clinicalTrials.contains(item);
  }

  public void removeClinicalTrial(Reference item) {
    if (hasClinicalTrial(item)) {
      clinicalTrials.remove(item);
    }
  }


  /**
   * A code that this product is known by, usually within some formal terminology, 
   * perhaps assigned by a third party (i.e. not the manufacturer or regulator). 
   * Products (types of medications) tend to be known by identifiers during 
   * development and within regulatory process. However when they are prescribed they 
   * tend to be identified by codes. The same product may be have multiple codes, 
   * applied to it by multiple organizations.
   *
   */
  public List<Coding> getCodes() {
    if (codes == null) { codes = new ArrayList<>(); }
    return codes;
  }

  public boolean hasCodes() {
    return codes != null && !codes.isEmpty();
  }

  public Coding addCode() {
    Coding theThing = new Coding();
    getCodes().add(theThing);
    return theThing;
  }

  public boolean hasCode(Coding item) {
    return hasCodes() && codes.contains(item);
  }

  public void removeCode(Coding item) {
    if (hasCode(item)) {
      codes.remove(item);
    }
  }


  /**
   * The product's name, including full name and possibly coded parts.
   *
   */
  public List<BackboneElement> getNames() {
    if (names == null) { names = new ArrayList<>(); }
    return names;
  }

  public boolean hasNames() {
    return names != null && !names.isEmpty();
  }

  public boolean hasName(BackboneElement item) {
    return hasNames() && names.contains(item);
  }

  public void removeName(BackboneElement item) {
    if (hasName(item)) {
      names.remove(item);
    }
  }


  /**
   * Reference to another product, e.g. for linking authorised to investigational 
   * product, or a virtual product.
   *
   */
  public List<BackboneElement> getCrossReferences() {
    if (crossReferences == null) { crossReferences = new ArrayList<>(); }
    return crossReferences;
  }

  public boolean hasCrossReferences() {
    return crossReferences != null && !crossReferences.isEmpty();
  }

  public boolean hasCrossReference(BackboneElement item) {
    return hasCrossReferences() && crossReferences.contains(item);
  }

  public void removeCrossReference(BackboneElement item) {
    if (hasCrossReference(item)) {
      crossReferences.remove(item);
    }
  }


  /**
   * A manufacturing or administrative process or step associated with (or performed 
   * on) the medicinal product.
   *
   */
  public List<BackboneElement> getOperations() {
    if (operations == null) { operations = new ArrayList<>(); }
    return operations;
  }

  public boolean hasOperations() {
    return operations != null && !operations.isEmpty();
  }

  public boolean hasOperation(BackboneElement item) {
    return hasOperations() && operations.contains(item);
  }

  public void removeOperation(BackboneElement item) {
    if (hasOperation(item)) {
      operations.remove(item);
    }
  }


  /**
   * Allows the key product features to be recorded, such as "sugar free", "modified 
   * release", "parallel import".
   *
   */
  public List<BackboneElement> getCharacteristics() {
    if (characteristics == null) { characteristics = new ArrayList<>(); }
    return characteristics;
  }

  public boolean hasCharacteristics() {
    return characteristics != null && !characteristics.isEmpty();
  }

  public boolean hasCharacteristic(BackboneElement item) {
    return hasCharacteristics() && characteristics.contains(item);
  }

  public void removeCharacteristic(BackboneElement item) {
    if (hasCharacteristic(item)) {
      characteristics.remove(item);
    }
  }




  public void clear() {
    id = null;
    extensions.clear();
    modifierExtensions.clear();
    identifiers.clear();
    marketingStatuses.clear();
    comprisedOfs.clear();
    attachedDocuments.clear();
    masterFiles.clear();
    contacts.clear();
    clinicalTrials.clear();
    codes.clear();
    names.clear();
    crossReferences.clear();
    operations.clear();
    characteristics.clear();

  }

}
